package apiserver

import (
	"fmt"
	"github.com/rs/cors"
	httpSwagger "github.com/swaggo/http-swagger/v2" // http-swagger middleware
	"github.com/yigithankarabulut/ConcurrentTaskService/src/internal/service/taskservice"
	"github.com/yigithankarabulut/ConcurrentTaskService/src/internal/service/workerservice"
	"github.com/yigithankarabulut/ConcurrentTaskService/src/internal/transport/http/httphandler"
	pkg "github.com/yigithankarabulut/ConcurrentTaskService/src/pkg/mysql"
	"time"

	_ "github.com/yigithankarabulut/ConcurrentTaskService/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/yigithankarabulut/ConcurrentTaskService/src/internal/models"
	"github.com/yigithankarabulut/ConcurrentTaskService/src/internal/repository/taskstorage"

	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"sync"
	"syscall"
)

// @ExternalDocs.description  OpenAPI
// @ExternalDocs.url          https://swagger.io/resources/open-api/
// @Summary         Initializes a new HTTP Server.
// @Description     This function initializes a new instance of the Task API server. It sets up the necessary components, including a database connection, logging, and a worker pool for processing tasks.

// @Param logLevel   The log level for the server. Use "debug", "info", "warn", or "error".
// @Param WorkerCount The number of worker goroutines in the pool for processing tasks.
// @Param ContextCancelTimeout The timeout for the context cancel function.
// @Param ShutdownTimeout The timeout for the Graceful Shutdown.
// @Param ServerReadTimeout The timeout for the HTTP server read function.
// @Param ServerWriteTimeout The timeout for the HTTP server write function.
// @Param ServerIdleTimeout The timeout for the HTTP server idle function.

// @Return error     Returns an error if the server fails to start.
func New(opts ...Option) error {
	apiServer := &apiServer{
		logLevel: slog.LevelInfo,
	}
	for _, opt := range opts {
		opt(apiServer)
	}
	db, err := pkg.ConnectDB()
	if err != nil {
		return err
	}

	if apiServer.logger == nil {
		logHandlerOpts := &slog.HandlerOptions{Level: apiServer.logLevel}
		logHandler := slog.NewJSONHandler(os.Stdout, logHandlerOpts)
		apiServer.logger = slog.New(logHandler)
	}

	slog.SetDefault(apiServer.logger)
	logger := apiServer.logger

	reqCh := make(chan models.TaskJobModel, WorkerCount)
	resCh := make(chan any, WorkerCount)
	errCh := make(chan error, WorkerCount)
	doneCh := make(chan struct{})
	wg := &sync.WaitGroup{}

	taskStorage := taskstorage.NewTaskStorage(taskstorage.WithTaskDB(db))
	taskService := taskservice.NewTaskService(taskservice.WithTaskStorage(taskStorage))
	workerService := workerservice.StartTaskWorker(
		workerservice.WithWorkerCount(WorkerCount),
		workerservice.WithWaitGroup(wg),
		workerservice.WithChannel(reqCh, resCh, errCh, doneCh),
		workerservice.WithService(taskService),
	)
	httpService := httphandler.New(
		httphandler.WithPool(workerService),
		httphandler.WithService(taskService),
		httphandler.WithContextTimeout(ContextCancelTimeout),
		httphandler.WithLogger(logger),
	)

	mux := http.NewServeMux()

	mux.HandleFunc(apiPrefix+"/set", httpService.Set)
	mux.HandleFunc(apiPrefix+"/get", httpService.Get)
	mux.HandleFunc(apiPrefix+"/update", httpService.Update)
	mux.HandleFunc(apiPrefix+"/delete", httpService.Delete)
	mux.HandleFunc(apiPrefix+"/list", httpService.List)
	mux.HandleFunc(apiPrefix+"/generate-jwt", generateJWT)
	mux.HandleFunc("/swagger/", httpSwagger.Handler(
		httpSwagger.URL("http://localhost:8080/swagger/doc.json"), //The url pointing to API definition
	))

	corsOptions := cors.New(cors.Options{
		AllowedOrigins:   []string{"*"},
		AllowedMethods:   []string{"GET", "POST", "PUT", "DELETE", "OPTIONS"},
		AllowedHeaders:   []string{"*"},
		AllowCredentials: true,
	})

	handler := corsOptions.Handler(mux)
	api := &http.Server{
		Addr:         ":8080",
		Handler:      jwtAuthMiddleware(rateLimiterMiddleware(httpLoggingMiddleware(logger, handler))),
		ReadTimeout:  ServerReadTimeout,
		WriteTimeout: ServerWriteTimeout,
		IdleTimeout:  ServerIdleTimeout,
	}

	shutdown := make(chan os.Signal, 1)
	apiErr := make(chan error, 1)
	signal.Notify(shutdown, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		logger.Info("starting api server", "listening", api.Addr)
		apiErr <- api.ListenAndServe()
	}()

	select {
	case err := <-apiErr:
		close(doneCh)
		return fmt.Errorf("listen and serve err: %w", err)
	case <-shutdown:
		logger.Info("shutting down", "pid", os.Getpid())
		defer logger.Info("shutdown complete", "pid", os.Getpid())
		close(doneCh)
		time.Sleep(ShutdownTimeout)
	}
	return nil
}
